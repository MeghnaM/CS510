(load "util.lisp")
(load "staterep.lisp")
(load "movgen.lisp")
(load "statecomp.lisp")
(load "compcheck.lisp")

;; Finds manhattan distance from master piece to the goal = h(n)
(defun mhtn (state)
  (let ((finalmin 0))
    (do* ((i 0 (1+ i))
          (mastercoords (coordinates state 2))
          (goalcoords (coordinates state -1))
          (m (nth i mastercoords) (nth i mastercoords)))
      ((>= i (length mastercoords)))
      (do* ((j 0 (1+ j))
            (g (nth j goalcoords) (nth j goalcoords))
            (absx (abs (- (car m) (car g))))
            (absy (abs (- (cadr m) (cadr g))))
            (sumacc (+ absx absy))
            (mindist sumacc))
        ((>= j (length goalcoords)))
        (setf absx (abs (- (car m) (car g))))
        (setf absy (abs (- (cadr m) (cadr g)))) 
        (setf sumacc (+ absx absy))
        (if (< sumacc mindist)
          (setf mindist sumacc))
        (setf finalmin mindist))) 
    finalmin))

;; Test:
;; (setf state (loadGameState "SBP-level0.txt"))
;; (outputGameState state)
;; (format t "~a~%" (mhtn state))

;; Finds the distance from the root to the current state = g(n)
(defun root-dist (rootstate currentstate)
  (let* ((root (coordinates rootstate 2))
        (curr (coordinates currentstate 2))
        (r (car root))
        (c (car curr))
        (absx (abs (- (car r) (car c))))
        (absy (abs (- (cadr r) (cadr c))))
        (totaldist (+ absx absy)))
    totaldist))

;; Test:
;; (setf state (loadGameState "SBP-level0.txt"))
;; (outputGameState state)
;; (format t "~%")
;; (setf newstate (applyMoveCloning state (list 2 "left")))
;; (outputGameState state)
;; (format t "~%")
;; (setf rdist (root-dist state newstate))
;; (format t "~a~%" rdist)

;; Gives the result of f(n) = g(n) + h(n)
;; Applies a move to a state, calculates g(n) and h(n) for the new state and returns the f(n) of the new state
(defun fdist (rootstate state move)
  (let* ((currstate (applyMoveCloning state move))
         (gn (root-dist rootstate currstate))
         (hn (mhtn currstate)))
    (+ gn hn)))

;; Returns a function that compares two states to see which one has the lower f(n)
(defun move-cmp (currentstate rootstate)
  (lambda (m1 m2) 
    (< (fdist rootstate currentstate m1) 
       (fdist rootstate currentstate m2))))

;; Calculates the optimum move according to the least value of f(n) = g(n) + h(n)
;; Returns a list of all the moves in order, the first of which has the lowest f(n) and so on..
(defun optmove (rootstate currentstate allmoves)
  (sort allmoves (move-cmp rootstate currentstate)))

;; Test:
;; (setf state (loadGameState "SBP-level0.txt"))
;; (outputGameState state)
;; (format t "~%")
;; (setf newstate (clonedGameState state))
;; (setf allmoves (allMoves state))
;; (setf bestmove (optmove state newstate allmoves))
;; (print bestmove)

;; A hashtable called visited-states that stores all the states that have been visited
(defvar visited-states (make-hash-table :test #'equal))

;; Checks to see if a move results in a visited state, and if it doesn't then the move is valid and the new state is added to the list of visited states
(defun validmove (moves currstate)
  (do* ((i 0 (1+ i))
       (move (nth i moves) (nth i moves))
       (valid nil))
    ((or (>= i (length moves)) valid) valid)
    (setf teststate (applyMoveCloning currstate move))
    (normalizeState teststate)
    (if (equal (gethash teststate visited-states) nil)
      (progn (setf (gethash teststate visited-states) t)
             (setf valid move)))))

;; Test:
;; (setf currstate (loadGameState "SBP-level0.txt"))
;; (outputGameState currstate)
;; (setf allmoves (allMoves currstate))
;; (setf newstate (applyMoveCloning currstate (list 2 "left")))
;; (setf sortedmoves (optmove currstate newstate allmoves))
;; (setf vmove (validmove sortedmoves currstate))
;; (print vmove)

;; Performs A* search on a puzzle
(defun astar-search (rootstate)
  (print "Initial State: ")
  (format t "~%")
  (outputGameState rootstate)
  (let ((stack (cons rootstate '()))
        (finalstate '()))
    (format t "~%")
    (do ((currstate (clonedGameState rootstate) (pop stack)))
      ((or (gameStateSolved currstate) (equal stack nil)))
      ;(print stack)
      ;(format t "~%")
      (outputGameState currstate)
      (setf allmoves (allMoves currstate))
      (setf sortedmoves (optmove rootstate currstate allmoves))
      ;(print sortedmoves)
      (setf bestmove (validmove sortedmoves currstate))
      ;(print bestmove)
      ;(print visited-states)
      (print bestmove)
      (if bestmove
        (progn (push currstate stack)
               (applyMove currstate bestmove)));(setf currstate (applyMoveCloning currstate bestmove))))
      (if currstate
        (normalizeState currstate))
      (setf finalstate currstate))
    (format t "~%")
    (print "Final State: ")
    (format t "~%")
    (outputGameState finalstate)
    (format t "~%")))

;; Test:
(setf currentstate (loadGameState "SBP-level0.txt"))
(astar-search currentstate)
